# 第十一章 k8s入门篇：架构-组件-核心资源

## Kubernetes 简介

1. K8s是可移植、可扩展、开源的容器管理平台，简称K8s：
2. 可移植：可从一个环境迁移到另一个环境
3. 可扩展：K8s集群可以横向扩展、根据流量使用实现扩缩容
4. 开源的：源代码已经公开了，可以被用户免费使用
5. 可以对容器自动化部署、自动化扩缩容、跨主机管理等；
6. 可以对代码进行灰度发布、金丝雀发布、蓝绿发布、滚动更新等；
7. 具有完整的监控系统和日志收集平台，具有故障自恢复的能力。

来源于Google的 Borg项目：
Borg是谷歌内部的一个容器编排工具，谷歌业务90%以上都在Borg上运行，Borg在谷歌内部已经使用了大概15年。 K8s是在Borg的基础上开发出来的轻量级容器编排工具。K8s的根基非常牢固，得益于Borg过去十数年间积累的经验和教训，是站在巨人的肩膀上发展起来的项目。开源之后，迅速称霸容器编排技术领域。



**架构**

* K8s的物理架构是master/node模式：
* K8s集群至少需要一个主节点(Master)和多个工作节点(Worker)，Master节点是集群的控制节点，负责整个集群的管理和控制，主节点主要用于暴露API，调度部署和节点的管理。工作节点主要是运行容器的。
* master节点: apiserver，controller-manager，scheduler，etcd
* node节点：kubelet，kube-proxy

![在这里插入图片描述](https://imgs.ilee.xyz/img/0864585ca81041faac67cef707ef3840.png)

![在这里插入图片描述](https://imgs.ilee.xyz/img/ff4ba303e31a4d1ba581abbee4af79eb.png)

**功能**

![在这里插入图片描述](https://imgs.ilee.xyz/img/54cd3afa12764540a7b33574da1426c3.png)

**控制节点组件**

* apiserver: 是Kubernetes控制平面的前端，负责提供Kubernetes API。所有的管理操作通过API服务器执行，其他组件通过API服务器进行通信。是整个系统的对外接口，提供资源操作的唯一入口，供客户端和其它组件调用，提供了K8s各类资源对象（pod,deployment,Service等）的增删改查，是整个系统的数据总线和数据中心，并提供认证、授权、访问控制、API注册和发现等机制，并将操作对象持久化到etcd中。相当于“营业厅”。使用etcd来存储集群的整体状态。
* etcd： 是一个高可用的键值数据库，存储K8s的资源状态信息和网络信息，配置数据、元数据。etcd中的数据变更是通过api server进行的。
* controller-manager：与apiserver交互，实时监控和维护K8s集群的控制器的健康情况，对有故障的进行处理和恢复，相当于“大总管”。
  kube-controller-manager包含了一组控制器，它们负责监视集群的状态并作出相应的调整。一些常见的控制器包括Replication Controller、Node Controller、Service Controller等。
* scheduler：负责将新创建的Pod调度到集群中的节点上。它根据各种因素（如资源需求、硬件/软件约束、亲和性和反亲和性规则等）来选择合适的节点。
* calico:提供网络插件，网络策略隔离
* coredns:k8s里的域名解析到对应IP



**工作节点组件**

* kubelet： 每个Node节点上的kubelet定期就会调用API Server的REST接口报告自身状态，API Server接收这些信息后，将节点状态信息更新到etcd中。kubelet也通过API Server监听Pod信息，从而对Node机器上的POD进行管理，如创建、删除、更新Pod
* kube-proxy：Kubernetes 中一个关键的网络组件，通过管理网络规则和代理服务，使得服务能够透明地与后端的 Pod 进行通信，从而构建了高度动态和可扩展的服务发现与负载均衡机制。
* Container Runtime： Container Runtime是负责运行容器的软件。Kubernetes支持多种容器运行时，包括Docker、containerd、CRI-O等。kubelet与容器运行时进行通信，以启动和管理容器
* CNI插件（Container Network Interface）： CNI插件负责为Pod创建和配置网络。它定义了如何在容器之间建立网络连接以及如何为Pod分配IP地址。
* Pod： Pod是Kubernetes中最小的可调度单元，通常包含一个或多个紧密关联的容器。Pod中的所有容器共享相同的网络命名空间、IP地址和存储卷，它们可以通过localhost进行通信。



**kube-proxy**

* 功能： 提供网络代理和负载均衡，是实现服务（Service）的通信与负载均衡机制的重要组件。
* 位置： 运行在每个节点上
* 任务：
  维护节点上的网络规则，以支持服务发现和负载均衡。
  通过在节点上创建虚拟IP和端口转发来提供服务访问
* 实现机制：
  从 Kubernetes API Server 获取所有服务信息。
  根据服务信息创建代理服务，建立服务到 Pod 的请求路由和转发。
  将服务的 IP 地址写入 iptables 或者 ipvs 规则中。
* 效果： 实现了 Kubernetes 层级的虚拟转发网络，确保将到服务的请求转发到后端的 Pod 上。
* 关键作用：
  为服务提供代理，实现服务间的通信。
  在节点上创建网络规则，支持服务发现和负载均衡。



**资源对象**

* Pod 是Kubernetes中的最小调度单元，当指派容器时，容器实际上并不会指派到物理硬件上，容器会被分配到一个Pod里。Pod代表集群上正在运行的一个进程，一个Pod封装一个容器（也可以封装多个容器），Pod里的容器共享存储、网络等。也就是说，应该把整个pod看作虚拟机，然后每个容器相当于运行在虚拟机的进程。
* Replicaset：用于确保指定副本数的 Pod 始终在运行，但支持更灵活的标签选择器（不常用，基本使用Deployment）
* Deployment管理Replicaset和Pod的副本控制器，Deployment可以管理多个Replicaset，是比Replicaset更高级的控制器，也即是说在创建Deployment的时候，会自动创建Replicaset，由Replicaset再创建Pod，Deployment能对Pod扩容、缩容、滚动更新和回滚、维持Pod数量。

![在这里插入图片描述](https://imgs.ilee.xyz/img/6e3c64c9f6244f32babdcc15bcb6a1f3.png)

* Statefulset：用于维护有状态应用，确保 Pod 在集群中的唯一标识和持久性存储。
* DaemonSet:用于确保在集群中的每个节点上运行一个 Pod 的副本，通常用于部署节点级别的服务。
* Job & CronJob：用于运行一次性任务或批处理作业，确保任务成功完成
  用于定期运行任务，类似于 Linux 中的 cron 任务。
* Service：不是直接控制器，但是用于提供 Pod 的网络服务，具有负载均衡和服务发现的功能。
  在kubernetes中，Pod是有生命周期的，如果Pod重启IP很有可能会发生变化。如果我们的服务都是将Pod的IP地址写死，Pod的挂掉或者重启，和刚才重启的pod相关联的其他服务将会找不到它所关联的Pod，为了解决这个问题，在kubernetes中定义了service资源对象，Service 定义了一个服务访问的入口，客户端通过这个入口即可访问服务背后的应用集群实例，service是一组Pod的逻辑集合，这一组 Pod 能够被 Service 访问到，通常是通过 Label Selector实现的。

![img](https://imgs.ilee.xyz/img/7ceff675dffa48508454be6a3bd20c47.png)

* Ingress ：维护七层代理的
* Configmap和Secret ：配置管理中心



**kubelet、kubeadm 和 kubectl 各自有的职责和功能。**

* kubelet 是运行在每个 Kubernetes 节点上的代理，负责管理该节点上的容器。它与容器运行时通信，确保容器按照 Pod 的规格运行。kubelet 还负责监控容器的状态，并向主控制平面报告节点的状态。
* kubeadm 是 Kubernetes 的一个命令行工具，用于在一个或多个节点上启动、初始化或升级 Kubernetes 集群。它提供了一个简化的方式来配置集群，而不必手动执行复杂的步骤。kubeadm 通常用于设置和管理集群的初始化过程。
* kubectl 是 Kubernetes 的命令行客户端工具，用于与 Kubernetes 集群进行交互。通过 kubectl，用户可以管理集群、部署和扩展应用、查看集群状态等。kubectl 可以用来执行各种操作，例如创建、删除和更新资源对象（如 Pod、Service、Deployment 等）。

**基于K8s构建DevOps流程图**

![在这里插入图片描述](https://imgs.ilee.xyz/img/d8e55c3b7ddc418c909f004f66b410e5.png)

> 开发代码->提交代码到代码仓库->Jenkins调K8s API->动态生成Jenkins Slave Pod->Slave Pod拉取git上的代码->编译代码->打包镜像->推送镜像到镜像仓库harbor或者docker hub->通过K8s编排服务发布到测试、生产平台-> Slave Pod工作完成之后自动删除>通过Ingress发布服务。
>



![image-20240707043122978](C:/Users/2021/AppData/Roaming/Typora/typora-user-images/image-20240707043122978.png)