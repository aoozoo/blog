# [RabbitMQ、RocketMQ、Kafka性能为何差距如此大？](https://heapdump.cn/article/5501994)

MQ的作用解耦、异步、削峰填谷。

- 未使用MQ的情况

![img](https://a.perfma.net/img/5501797)

mysql并发写大部分情况下维持在600-800之间，并发读1200-1500之间，所以消费端在消费消息的时候需控制在并发小于1000，从而达到限流的效果。

- 使用MQ的情况

![img](https://a.perfma.net/img/5501811)

mq做个缓冲，消息放到磁盘，几个G或上t都可以存储，消息丢失的可能性比较小。

## 使用MQ需要面临的问题

```
可用性降低
```

多了MQ，对外部依赖增加，但通过try-catch兜底，mq消息发送失败，则插入数据库。

```
提高复杂度
```

需要搭建高可用的Kafka集群或RocketMQ集群。

```
消息重复
```

通过消费端的幂等性实现。

中间生产消息的时候，有可能会发生网络的波动，业务程序认为消息没有发送成功，其实消息已经写入了一条，应用端超时timeout，此时会进行消息的重发即2个id为1的都会写入到mq中，后端应用消费的时候，就会消费到2条消息。

```
消息顺序
```

比如下单、支付、发送物流通知，这3个业务消息并发的产生且后端多线程消费的情况下，需要考虑消息消费顺序的问题。

解决的方式是单个消费者、单个生产者、单个队列可以保证消息有序的消费。

一个主题，多个队列的情况下需要通过负载均衡的方式路由到不同的队列中来。

有多个消费者不能确保消息消费的顺序。

```
一致性问题
```

A、B、C三个系统，A和B两个写入数据库成功了，C系统写库失败，这种情况可以用分布式事务解决，可以使用RocketMQ提供的分布式事务或阿里开源的Seta。

## 对比下常用的MQ

```
RabbitMQ
```

支持并发1.2W。

RabbitMQ集群很弱，主要确保高可用，不能拓展性能。

想性能更高，得搭建多主多从，比如3主3从、4主4从，第一个可以确保高可用，第二个可以提高整个的性能，但RabbitMQ集群不可以这样拓展性能。

```
Kafka
```

支持并发100W。

```
RocketMQ
```

支持并发10W。

Kafka、RocketMQ天生支持分布式，支持动态扩展、动态扩缩容。

RocketMQ相对来说功能也比较丰富，支持死信消息、延迟（基于死信消息可以实现延迟消息）消息、消息的回溯、消息的过滤。

Kafka不支持死信消息。

![img](https://a.perfma.net/img/5501814)

消息端消费成功，发起ACK确认，作为RabbitMQ来说，可以直接把这个消息删掉。

Kafka或RocketMQ会记录消息者的偏移量，保证下一次消费的时候不会消费同一条消息。

```
死信消息
```

如果消费很多次还没有成功，比如10次、20次都不能消费成功，mq中的这个消息就不能被确认 ，这个时候就引入了死信消息，进入一个单独的死信队列进行保存，后续进行手工处理或额外处理，比如用消息补偿机制，实在消费不了的则异步通知生产者。

RabbitMQ在ack确认很多次都没有成功返回的时候，则会设置一个标识，就会认为这个消息是死信消息，就会把这个消息写入DCL队列中。

RocketMQ也有这样的死信消息，如果消息重试的次数超过16次，作为RocketMQ也会把这个消息写入专门的死信队列中去。

补偿机制要根据业务来，比如微信冲电话费，在微信应用里面，通过异步的方式来通知成功或失败，如果说失败了，失败的补偿机制就是退费；如果这条消息反正也消费不了，不知道出于什么原因，也有可能加入了失信名单 或超过了消费的额度，这个时候就消费不了，多次尝试之后，在微信的后端就认为是死信消息，而退费就是一种补偿机制。

```
延迟消息
```

一般情况下，消息只要发到mq，消费者就会里立马消费掉，但是有的业务场景需要在这个消息上加一个延迟的时间，比如延迟10分钟再被消费。

应用场景比如买电影票-线上电影票的购票流程：

1、选座位，对这个座位进行锁定，防止再被其他人锁定

2、必须在10分钟之内支付

异常情况：选了座位，不支付。

对于后端系统来说，只要锁定过期且没有支付，就需要把座位释放掉。

这种情况可以采用定时任务来处理，不断的去轮循数据库，但会出现新的问题，1要查询数据库，2每个人选定的时间不一样，若定时10分钟跑一次，就会出现释放座位不及时的情况，若定时1秒跑一次，系统性能开销比较大。

最优的方案是采用延时消息，每一次选座位的时候，就写一个延时10分钟的消息，在消费的时候，必须等10分钟之后，消费者再处理，不需要轮询数据库。

```
不同MQ为什么性能差别这么大？
```

主要依赖于Rabbitmq、Kafka持久化的底层机制：将消息写入磁盘的零拷贝技术。

Netty、Nginx都有用到该技术。

零拷贝包括MMAP的零拷贝、Sendfile的零拷贝。

## RabbitMQ传统方式的拷贝

作为消费者要拉取消息进行消费，站在IO的角度去看，为了确保消息的高可用，往往把消息放到磁盘，一旦数据没有写入磁盘就会有丢失数据的可能性，所以消息会先写入磁盘。

![img](https://a.perfma.net/img/5501817)

把数据从磁盘读出，再通过网络发送给消费者。

应用发送数据要先发送给操作系统的网卡，最终通过网卡发送数据给消费者。

站在磁盘的角度来看，数据首先要经过第一个拷贝，这里叫DMA拷贝到文件读取缓冲区，伪代码为buffer=file.read ，写完之后，发给消费者，创建一个socket即建立一个TCP网络通信，通过socket调用send方法，把读到的buffer进行发送。

站在io的角度来看，经过了几次拷贝？

第一次：数据从磁盘拷贝到内核的文件读取缓冲区，这个过程称为DMA拷贝，

然后数据经过第二次拷贝：CPU拷贝，拷贝的数据放入应用缓冲区即就是刚才定义的buffer字节流。

应用程序并不能直接操作网卡，底层调用socket，通过socket调用操作系统的网卡，但是操作系统网卡会有一个问题 ：不能直接读到应用的内存，所以又需要经过一次CPU拷贝到套接字发送缓冲区，最后再经过一次DMA拷贝（直接内存读取 Direct Memory Access）。

内核或操作系统的驱动允许不同速度的硬件进行沟通的时候才会有DMA拷贝。

如果没有DMA，就需要通过CPU的大量中断来进行负载。

```
什么叫中断?
```

在计算机里面，启动一个线程，让CPU来跑，CPU在跑的时候，你给我发了一个消息，我的电脑怎么知道我的网卡里面进来一条消息呢？这个就需要网卡在硬件级别叫下CPU：cpu等一等，现在我要打断你一下。

如果通过CPU负载的话，效率很低，因为CPU干很多事情，CPU做大量中断负载的话，比如200M的数据，如果通过CPU拷贝，大概需要200ms，而通过DMA拷贝，速度只需要2毫秒。

计算机里面，越底层的东西就越快，通过CPU拷贝到话，效率往往很低，因为这个时候还需要向CPU请求负载， 这里会涉及到很多的中断负载的切换。

在不考虑MQ应用程序运转多少时间的情况下，传统的拷贝大概需要404毫秒。

```
RocketMQ MMAP零拷贝技术
```

在RocketMQ中采用一种MMAP的零拷贝技术，本身是做内存映射，当内存的应用缓冲区调用操作系统的mmap函数，可以做一个内存映射。

![img](https://a.perfma.net/img/5501832)

![img](https://a.perfma.net/img/5501837)

拿到能够操作文件的通道到一个高级类FileChannel，这个高级类实际上是对文件进行操作。

底层会调用操作系统的mmap函数来完成映射，映射的意思是内存即磁盘，磁盘即内存，如果完成映射之后，这个文件和内存的这个buffer（ByteBuffer）就一致了。

mmap是内存文件通过FileChannel调用map方法间接调用的，设置读写模式，文件映射到底可以读还是可以写，内存映射的位置即从哪里开始，0表示从头开始，内存映射大小为1024即这个文件可以映射1kb左右，拿到这个buffer之后，就可以进行写入，这个ByteBuffer和Hashmap是一样的方式，直接put把字符串转换成byte数组进行写入，写入完之后，再去调用flip方法进行刷盘，这个数据就可以同步到磁盘了，当然刷完盘之后，还可以拿出来，通过mmap.get把里面的前5个数据读取出来，读取之后还可以打印，

![img](https://a.perfma.net/img/5501848)

文件中这么多NULL，刚好长度是1024。

通过mmap创建的，因为它进行内存映射，所以这个文件必须要有空格，通过NULL值进行表示，读的时候，通过偏移量+长度，指定了5个长度，就可以读取到lijin这个字符串数据。

```
传统的方式
```

![img](https://a.perfma.net/img/5501866)

Server端（服务端）启动，模拟一个消费者即专门启动一个Server Socket监听，接受到数据，把数据读出来就可以了。

![img](https://a.perfma.net/img/5501869)

这个是传统的客户端读一个文件发送到网络的过程，这段代码跟![img](https://a.perfma.net/img/5501873)

这个的业务场景是一样的。

创建一个socket，因为要发给对应的消费者，先建立一个网络连接。

inpuStream.read()会进行2次拷贝，一个是DMA拷贝，一次是CPU拷贝。

![img](https://a.perfma.net/img/5501890)

而这种方式只是一次拷贝，因为是内存映射。

map方法在系统启动的时候就被调用了。

传统的方式，每次都要new一个FileInputStream，这里涉及到了2次拷贝（每一次读取出来，读到buffer中，涉及到2次拷贝：一次DMA拷贝、一次CPU拷贝），耗时202毫秒，因为要发送网络，通过连接本机的8081端口，发送给它，还要创建一个对应的输出流拿取结果。

传统的方式本质上和文件读取是一样的，这是通过流的方式读取，while true不断的读并且累加，读完之后，拿到了buffer，再写网络，网络就通过socket创建的getOutputStream（文件的输出流、socket的输出流）转到DataOutputStream。

创建的socket就是一个连接，应用要跟消费者建立一个TCP的连接，这个TCP的连接在底层表示都是socket，不单单只是数据连接，还包含了数据通道，这里new一个socket就相当于跟另外一个消费者8081这样的socket通道建立了链接，通过socket通道里面的dataOutputStream.write方法输出数据，这里又会涉及到一次DMA拷贝，一次CPU拷贝。

首先做一次CPU拷贝，相当于把buffer的数据首先要发到套接字缓冲区（socket里面的缓冲区），这个socket要通过网卡发给消费者最终要把应用内存发送给网卡里面的内存，网卡是一个外设，网卡通过一个USB都可以去接，所以就需要做一个DMA拷贝。

这种方式共有4次拷贝，耗时为422毫秒，这是RabbitMQ的情况，而RocketMQ的mmap发送只有204毫秒，DMA拷贝速度一般是CPU的百倍。

```
Kafka的sendfile零拷贝技术
```

![img](https://a.perfma.net/img/5501898)

Kafka不会涉及到cpu拷贝，只是进行文件描述符的传递，这点消耗的时间可以忽略。

文件描述符类似一个指针，在linux上面所有东西都是文件描述符。

把数据放到文件数据读取缓冲区，这里就会有一个文件描述符，类似于网盘的地址，比如百度云网盘的分享链接，而真实的数据放百度网盘，这种开销可以忽略，既然数据已经放到了文件缓冲区，只要拿到文件缓冲区的指针，指针在应用程序里面内存的大小就可以忽略不计了。

在现代新的操作系统里面，既然都属于内核操作系统的进程，文件读取缓冲区的内存和套接字的内存可以共享。

文件描述符（offset=1024，size=9721823），比如要读取的文件，偏移量是1024，读取9721823这个大小的数据。

把文件描述符传给应用，这个速度和时间可以忽略不计，调用socket，相当于告诉socket你要去文件读取缓冲区内存找我要发送的数据，因为我已经告诉你偏移量和大小了。

通过sendfile的方式，只剩下2次DMA拷贝了，数据的传输基本上在内核就完成了。![img](https://a.perfma.net/img/5501917)

第一步new出一个SocketChannel，使用8081的服务器地址，SocketChannel是套接字发送缓冲区的一个通道，FileChannel是针对磁盘文件的通道，2个通道通过transferTo进行共享，

![img](https://a.perfma.net/img/5501926)

共享的位置是从0开始，长度是文件大小，这里没有使用多文件，只读了一个文件。

fileName可以通过FileChannel传过去，传过去就已经网络传输了，只要调用transferTo方法就会完成网络发送，这种方式的耗时只需要16毫秒。

传统的传输要转换成InputStream、FileInputStream、DataOutputStream，所以开销会大些，同样的一张图片，转换出来的字节流会多一点。

通过NIO转换transferTo直接就这么转了，如果把中间的CPU拷贝的时间忽略，相当于2+2+12，传输文件描述符的话，还是会占据一点点时间。

不同的序列化方式即转换的流不一样，传输的字节数大小也不一样。

```
为什么Kafka不用mmap
```

既然sendfile零拷贝技术效率更高，RocketMQ早期版本也是基于Kakfa java版本重写改进的，那RocketMQ为什么不用sendfile技术？

因为它们的设计理念不一样。

作为文件描述符等同于网盘地址。

RocketMQ有很多功能的延伸点是不一样的，比如延迟消息、死信消息需要数据流转到MQ应用。

RocketMQ要支持延迟消息，数据最好要进入应用，不能单纯拿一个文件描述符做延迟消息，这也是为什么Kafka没有延迟消息的原因。

![img](https://a.perfma.net/img/5501955)

数据是通过这样的方式发送的，数据不会直接经过Kafka。

Kafka的设计比较简单，没有延迟消息、死信消息等。

比如1万条消息中有一个消息发送不成功，这种情况一定要放到mq的应用内存才能处理，

而通过sendfile方式，很多的消息数据都是文件读取缓冲区的文件描述符。

类似网盘资料中的数据很多，是一个代码压缩包，单独把其中的一段代码拿出来是非常麻烦的。

Kafka做死信消息，要写一个定时器，不断的轮询，如果消息失败了，把这个消息写入到Kafka的一个文件或一个队列中，可以这样变相的实现，但自身原生是不支持死信消息的。

 







# [详解三大MQ：RabbitMQ、RocketMQ、Kafka](https://developer.aliyun.com/article/1535404?spm=a2c6h.12873639.article-detail.23.60d22044bv0ExW&scm=20140722.ID_community@@article@@1535404._.ID_community@@article@@1535404-OR_rec-V_1-RL_community@@article@@1206478#slide-7)

## 1.概述

### 1.1.MQ简介

消息中间件，其实准确的叫法应该叫消息队列（message queue），简称MQ。其本质上是个队列，有FIFO的性质，即first in first out，先入先出。

目前市场上主流的MQ有三款：

1. RabbitMQ
2. RocketMQ
3. Kafka

### 1.2.MQ的应用场景

MQ一般用在几种场景：

1. 流量削锋
2. 应用解耦
3. 异步任务

**1.流量削锋**

流量过大的时候，用MQ作为一个中间层，暂时存储流量，让流量在队列中排队去访问服务，从而控制直接访问服务的流量，减轻服务的实时流量压力。

以网购下订单为例：

![image](https://imgs.ilee.xyz/img/lni4yqsropaa4_eb80e0f715184e1997f22d0258a588fa.png)



**2.应用解耦**

使用MQ作为应用之间的中间层，从而使得应用直接不存在直接调用的关系，解除应用之间的耦合。这样在被调用的应用挂掉以后，应用之间的调用不会直接产生异常，请求仍可以正常发送，待被调用应用重新起来以后，再去消费处理MQ中挤压的调用请求，为系统的修复争取到了时间

以支付系统为例：

![image](https://imgs.ilee.xyz/img/lni4yqsropaa4_3530e765a65448c4b0fac7f415b3850f.png)

**3.异步任务**

有些服务调用对于响应的实时性要求不高，允许延迟响应、异步处理。使用MQ可以将这些可以异步处理的请求，暂存在队列中，调用方不必等待，直接向下执行其他任务，被调用方消费MQ中消息后自行返回给调用方响应。

![image](https://imgs.ilee.xyz/img/lni4yqsropaa4_0d0bb889fe824a73abdb440fde74f11f.png)



### 1.3.关注MQ的角度

虽然市面上的MQ数量众多、种类繁杂，但MQ其本质上就是用来暂时存放消息的一种中间件，其实从三个角度去关注MQ即可抓住MQ的核心：

1. 消息可靠性
2. 消息模型
3. 吞吐量

**1.消息可靠性**

消息可靠性，即消息会不会丢失？围绕防止消息丢失做了哪些工作？

**2.消息模型**

消息模型，即支持以什么样的模式去消费消息？点对点？广播？发布订阅？其消息模型丰富度如何？

**3.吞吐量**

MQ作为用来减轻系统压力的中间件，其自身势必会经常面对很大的流量，吞吐量如何自然是要考虑的。

本文在最后横向对比三大MQ的时候就会从以上三点出发。除了以上三点，还有一点是值得额外关注的，就是扩容是否方便，即是否在架构上能很好的支持分布式架构。当然这不是核心点，要扩容怎么都能扩，只是看方便与否。

## 2.RabbitMQ

![image](https://imgs.ilee.xyz/img/lni4yqsropaa4_41715246328647299f0fa6606ffa2912.jpeg)



RabbitMQ有几个特点：

1. 遵从AMQP协议
2. 丰富的消息模型极
3. 消息可靠性高但是吞吐量不高

**1.遵从AMQP**

博主在之前的中间件系列中详细介绍了AMQP：

[详解AMQP协议__BugMan的博客-CSDN博客](https://blog.csdn.net/Joker_ZJN/article/details/132037929?ops_request_misc=%7B%22request%5Fid%22%3A%22169401634716800185871169%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=169401634716800185871169&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-132037929-null-null.268^v1^koosearch&utm_term=AMQP&spm=1018.2226.3001.4450)



**2.丰富的消息模型**AMQP简单来说就是规定好了MQ的各个抽象组件，RabbitMQ则是一款完全严格按照AMQP来实现的开源MQ，使得很好被开源框架所集成，比如Spring AMQP专门就是用来操作AMQP架构的中间件的，因此RabbitMQ可以被Spring Boot很方便的集成。

RabbitMQ也是三大MQ里提供的消息模型最丰富的一种MQ。

 3.消息可靠性高但是吞吐量不高



RabbitMQRabbitMQ 提供了多种机制来确保消息的可靠性，包括持久化、消息确认、发布确认等。这些机制确保消息不会丢失，并且能够在各种情况下处理消息传递失败。但是由于存在这些用于保证消息可靠性的机制，RabbitMQ的吞吐量在三大中间件中是最低的。

## 3.RocketMQ

![image](https://imgs.ilee.xyz/img/lni4yqsropaa4_8da06b28108c4f3aac50034068b51cbf.png)

RocketMQ是一款开源的分布式消息中间件，最初由阿里巴巴集团开发并开源。它旨在为分布式系统提供可靠、高性能、可扩展的消息通信能力。其已经是阿里内部最核心的消息中间件，用来保证每年双十一期间系统的稳定。

Rocket安装使用：

[RocketMQ下载安装、集群搭建保姆级教程_rocketmq集群安装__BugMan的博客-CSDN博客](https://blog.csdn.net/Joker_ZJN/article/details/131654750)

RocketMQ有以下几个特点：

1. 天生的分布式架构

1. 兼顾消息可靠性和高吞吐量
2. 消息模型够用

**1.天生的分布式架构**

RocketMQ 的设计采用了分布式架构，可以将消息存储和处理分散到多个节点上。这样可以实现消息的并行处理，提高系统的吞吐量和并发性能。整个RocketMQ集群的架构和微服务架构类似，有一个存放节点信息的name server，生产者和消费者都去找name server拿broker的信息，再去定位到具体的某一个broker上，进行消息的收发。 broker之间可以用主从的方式进行互相备份，进行容错。

![image](https://imgs.ilee.xyz/img/lni4yqsropaa4_71d27d275eb343f4b0faffe74a618938.png)

2.兼顾消息可靠性和高吞吐量



可靠性和吞吐量其实是互斥的两点，为了保证可靠性，消息就一定要落在磁盘存储防止断电丢失。落在磁盘存储后，读这条消息的时候的磁盘IO就会拉低吞吐量。所以RocketMQ的核心其实就是数据落磁盘，然后想尽一切办法来提高吞吐量。RocketMQ主采用了顺序读写、异步刷盘、零拷贝三大机制来拉升了吞吐量。







3.消息模型够用



RocketMQ的消息模型没有RabbitMQ那么够用，但是基本的点对点、广播、发布订阅、事务等都是有的，面对绝大多数场景基本上是够用的。



## 4.Kafka

![image](https://imgs.ilee.xyz/img/lni4yqsropaa4_88082c3bcfa4451abba20377c5b1e888.png)

Kafka其实和RocketMQ很相似，一款具有高吞吐量、高可靠性的分布式消息中间件。其采用**分布式架构**、**顺序写**、**序列化**、**零拷贝**等机制保证了高吞吐量，**数据自动落磁盘**完成持久化来保证消息不会丢失。





## 5.三大MQ的对比

重头戏来了，在实际开发中，要用到MQ时，对MQ的选型是很重要的，选型的基础是一定要了解MQ的特点和适用的场景。

**Kafka:**

- 优点：
- 吞吐量：Kafka的设计目标是实现高吞吐量的消息传递，拥有很大的吞吐量，适用于处理大量的实时数据流。
- 扩展性：Kafka采用分布式架构，允许构建具有高可用性和可伸缩性的消息系统。

- 可靠性：Kafka将消息持久化到磁盘上，可以长期保留数据，并支持高效的消息回放。

- 缺点：

- 复杂性：Kafka的配置和管理相对较复杂，需要一定的学习和运维成本。

- 实时性：由于Kafka是批量处理数据的，并且由于需要在分区之间进行数据的复制和同步，所以相对于其它MQ，kafka会存在一定时延。
- 功能丰富度：支持的消费模式比较单一

**RabbitMQ:**

- 优点：

- 功能丰富度：RabbitMQ支持灵活的路由机制和多种消息模式，如点对点、发布-订阅和主题订阅等。
- 可靠性：RabbitMQ通过消息确认机制和持久化可以保证消息的可靠传递。

- 兼容性：RabbitMQ使用标准的AMQP协议，支持跨语言和平台的互操作性。

- 缺点：

- 吞吐量：没有做拉升吞吐量的优化所以相比于其他消息队列系统，RabbitMQ的吞吐量较低。

- 扩展性：RabbitMQ的集群管理较为复杂，需要很多额外的配置和管理。

**RocketMQ:**

- 优点：

- 高吞吐量和低延迟：RocketMQ是为处理大规模数据流设计的，具有高吞吐量和低延迟的特点。RocketMQ的时延。

- 可靠性：存在持久化机制、确认机制，具有高可靠性。
- 扩展性：RocketMQ支持水平扩展，可以通过添加更多的节点来提高系统的性能和容量。

- 缺点：

- 社区支持：相对于Kafka和RabbitMQ，RocketMQ的社区支持相对较弱。
- 功能丰富度：RocketMQ在功能上相对较为简化，可能不适用于复杂的消息处理场景。

**适用场景：**

- RabbitMQ适用于对消息可靠性要求高或者灵活的消息路由和多种消息模式的场景，如任务队列、发布-订阅和事件驱动架构。

Kafka虽然存在一些时延，但是这个时延并不会很大，总体上来说Kafka和rocket适用的场景是高度重叠的，RocketMQ和Kafka都专注于高吞吐量和低延迟的场景，因此它们都适用于需要处理大规模数据流和实时消息传递的应用。Kafka在大数据领域具有广泛的应用，与Hadoop、Spark等工具有良好的集成。RocketMQ在互联网领域应用较为广泛，适用于电商、物流等场景。



# [为什么kafka延迟比rocketmq延迟高](https://developer.aliyun.com/article/1206478)

说kafka延迟比rocketmq延迟高 是有一个前提的 就是topic较多的时候 这个和这2个MQ的数据存储结构有关系的 在topic少的时候延迟基本一致。



kafka的数据存储结构设计师尽可能的保证吞吐量，所以在设计时是尽可能保证log日志小，它的数据结构如下 其中topic是逻辑概念，分区对应就是一个物理文件夹：



![11.png](https://imgs.ilee.xyz/img/julu4p6dzrf6a_07b6e8a2dc5c4bbdb5f04856b77ae077.png)



所以在topic比较多时，分区文件数量会非常庞大 磁盘顺序读效率还不如随机读效率，则会在topic比较多时 磁盘顺序读就蜕变为随机读，延迟也就高了。



即 kafka 性能对于topic 有阈值（20 个）。



淘宝业务比较复杂，topic会比较多 则为了解决这个痛点 rockertmq 就诞生了 它的数据存储结构 对此做了优化 日志目录只有一个 commit log ，结构如下：

![10.png](https://imgs.ilee.xyz/img/julu4p6dzrf6a_381b251b925f4d968b01908fa7a7f3c1.png)





出发点不一样，kafka定位就是处理日志和大数据 在这些业务领域，topic不会太多，延迟问题自然也就没有。



数据存储结构是主要原因，还有就是kafka只支持pull模式。而rocketmq有pull、push两种模式 （虽然这个push模式是假push），push模式延迟肯定是比pull模式延迟低。



push模式是基于pull模式的，本地有个定时线程去pull broker的消息，缓存到本地，然后push到消费线程那边。



rabbit 的push模式 是真的push 所以 延迟最低的就是兔子。 兔子不支持分布式，只支持主从模式 本身设计就是小而美的单机版。cpu消耗比kafka之类低多了。



# [RabbitMQ、RocketMQ 和 Kafka 介绍](https://developer.aliyun.com/article/1548626?spm=a2c6h.12873639.article-detail.26.60d22044bv0ExW&scm=20140722.ID_community@@article@@1548626._.ID_community@@article@@1548626-OR_rec-V_1-RL_community@@article@@1206478)

我了解 RabbitMQ、RocketMQ 和 Kafka。以下是对这三种消息队列系统的详细介绍：

## RabbitMQ

### 概念

RabbitMQ 是一个由 Pivotal 开发的开源消息代理，基于 AMQP（Advanced Message Queuing Protocol）协议。它支持多种消息模型，如发布/订阅、点对点和 RPC。

### 优点

1. **灵活性**：支持多种消息模型和协议，包括 AMQP、MQTT 和 STOMP。
2. **可靠性**：提供消息持久化、确认机制，确保消息不丢失。
3. **社区支持**：有广泛的社区支持和丰富的插件。
4. **易于使用**：配置和管理相对简单，适合中小型应用。

### 缺点

1. **性能**：在高吞吐量场景下性能可能不如 Kafka 和 RocketMQ。
2. **复杂性**：AMQP 协议较为复杂，需要一定的学习成本。
3. **扩展性**：在大规模分布式系统中扩展性相对较弱。

## RocketMQ

### 概念

RocketMQ 是阿里巴巴开源的分布式消息中间件，支持高吞吐量和低延迟。它适用于大规模消息处理场景，如日志处理和交易系统。

### 优点

1. **高性能**：支持大规模消息的快速传输，低延迟。
2. **丰富功能**：支持事务消息、定时消息和顺序消息。
3. **伸缩性**：易于水平扩展，适合大规模分布式系统。
4. **可靠性**：消息存储采用了多副本机制，确保数据的高可用性。

### 缺点

1. **生态系统**：相比 RabbitMQ 和 Kafka，RocketMQ 的社区和生态系统相对较小。
2. **运维复杂**：需要较多的运维操作和监控，尤其是在大规模集群环境中。

## Kafka

### 概念

Kafka 是 Apache 基金会的一个开源流处理平台，最初由 LinkedIn 开发。Kafka 提供高吞吐量、低延迟的消息传输，特别适用于实时数据流和事件流处理。

### 优点

1. **高吞吐量**：能够处理每秒数百万条消息，非常适合大数据场景。
2. **持久性**：支持将消息持久化到磁盘，确保数据安全。
3. **生态系统丰富**：拥有丰富的生态系统和工具，如 Kafka Streams 和 Kafka Connect。
4. **扩展性**：易于扩展，支持分布式部署。

### 缺点

1. **复杂性**：需要熟悉其架构和配置，初次上手有一定难度。
2. **延迟**：在某些场景下，消息的实时性不如 RocketMQ。
3. **消息顺序**：在某些场景下保证消息的全局顺序可能比较复杂。

## 对比总结

1. **性能**：Kafka 和 RocketMQ 通常具有更高的吞吐量和性能，适合大规模数据流处理。RabbitMQ 在高吞吐量场景下可能表现不如前两者。
2. **灵活性**：RabbitMQ 支持多种消息模型和协议，适合各种不同场景，但其协议复杂性较高。Kafka 和 RocketMQ 更专注于高吞吐量和低延迟。
3. **生态系统**：Kafka 拥有最为丰富的生态系统和工具支持，如 Kafka Streams 和 Kafka Connect。RabbitMQ 和 RocketMQ 的生态系统相对较小。
4. **易用性**：RabbitMQ 配置和管理相对简单，适合中小型应用。Kafka 和 RocketMQ 需要更多的运维和配置工作，适合大规模分布式系统。

## 使用场景

- **RabbitMQ**：适用于中小型应用，需要多样化的消息模型和协议支持的场景，如企业应用集成、分布式系统的组件间通信。
- **RocketMQ**：适用于需要高吞吐量和低延迟的大规模消息处理场景，如电商交易系统、日志处理系统。
- **Kafka**：适用于需要处理大规模实时数据流和事件流的场景，如大数据分析、实时日志处理、数据管道。

以上是对 RabbitMQ、RocketMQ 和 Kafka 的详细介绍及其优缺点和适用场景的分析。根据具体的需求和场景选择合适的消息队列系统，可以更好地满足项目需求。